--[[
	utils_json.script by Penomatikus, 2023

	Provides two global functions to create valid JSON from the following Lua types:
	boolean, number, string, table (recursive parsing), userdata( CTime -> RFC3339+02:00) and nil.  

	The implementation is using the dispatcher pattern to decouple concerns by defining a handler 
	for each type listed above. It maps these types to corresponding handlers, which are called to 
	process the input.
	
	Use to_json(value, keyname) to create a JSON string: 
	utils_json.to_json(db.actor:character_community(), "faction")
	will result in: 
	"{
		"faction": ""actor_zombied""
	}"

	Use to_logfile(value, filename) to write ./appdata/logs/<filename>.json:
	utils_json.to_logfile(game_statistics.actor_miscellaneous, "actor_miscellaneous")
	will create ./appdata/logs/actor_miscellaneous.json, with the following content:
	{
		"actor_miscellaneous": {
			"actual_rept": 30,
			"actual_rank": 148
		}
	}

]]

local open = "{"
local close = "}"
local ln = "\n"

---Repeat "\t" node_depth times to ident a nodes value correctly 
---@param node_depth number
---@return string
local function ident(node_depth) return string.rep("\t", node_depth) end 
---Bake the json-data into "{ }"
---@param data string
---@return string
local function bake_json(data) return open .. ln .. data .. ln .. close end
---Opposite of bake_json(data), just return the data without "{ }"
---@param data string
---@return string
local function no_bake(data) return data end

--------------------------------------------------------------
-- Local functions: dispatcher & handlers
--------------------------------------------------------------

---json_handlers registes the handlers
local json_handlers = { }

---A dispatcher to choose the correct json handler by the type of value
---@param json_key string
---@param value any
---@param node_depth number
---@param bake_Fn? function
---@return string
local function type_dispatcher(json_key, value, node_depth, bake_Fn)
	local cmd = type(value)
	printdbg("~ utils_json | value is [%s]", cmd)
	local handler = json_handlers[cmd]
	if not handler then
		err_not_implemented = "no json handler implemented for: " .. cmd
		return json_handlers["string"](json_key, err_not_implemented, node_depth, no_bake)
	end
	return handler(json_key, value, node_depth, bake_Fn)
end

---A json handler for lua tables
local function table_handler(json_table_name, t, node_depth, bake_Fn)
	bake_Fn = bake_Fn and bake_Fn or bake_json
	local json = ""
	local p_node_depth = node_depth
	local c_node_depth = node_depth + 1

	-- open then new json node
	json = string.format('%s"%s": %s', ident(p_node_depth), json_table_name, open)
	-- close it immediately, if the table is empty
	if not next(t) then
		return json .. close
	end

	json = json .. ln

	for k, v in pairs(t) do 
		-- since the table_handler uses his own baking, the dispatcher is called without the bake option
		json = json .. type_dispatcher(k, v, c_node_depth, no_bake)
		-- End of node check
		json = json .. (next(t, k) and "," .. ln or ln .. ident(p_node_depth) .. close)
	end

	return bake_Fn(json)
end

---A json handler for lua numbers
local function number_handler(json_key, n, node_depth, bake_Fn) 
	bake_Fn = bake_Fn and bake_Fn or bake_json
	return bake_Fn(string.format('%s"%s": %s', ident(node_depth), json_key, tostring(n)))
end

---A json handler for lua booleans
local function boolean_handler(json_key, b, node_depth, bake_Fn) 
	bake_Fn = bake_Fn and bake_Fn or bake_json
	return bake_Fn(string.format('%s"%s": %s', ident(node_depth), json_key, tostring(b)))
end

---A json handler for lua nil values
local function nil_handler(json_key, v, node_depth, bake_Fn) 
	bake_Fn = bake_Fn and bake_Fn or bake_json
	v = "null"
	return bake_Fn(string.format('%s"%s": %s', ident(node_depth), json_key, v))
end

---A json handler for lua strings
local function string_handler(json_key, s, node_depth, bake_Fn) 
	bake_Fn = bake_Fn and bake_Fn or bake_json
	return bake_Fn(string.format('%s"%s": "%s"', ident(node_depth), json_key, tostring(s)))
end

---TODO: This obsolete, I need to to get the arg-list in Lua 5.1
---A json handler for lua functions
local function function_handler(json_key, f, node_depth, bake_Fn)
	bake_Fn = bake_Fn and bake_Fn or bake_json
	local func = (debug.getinfo(f, "n").name or "anonymous") .. "( )"
	return bake_Fn(string.format('%s"%s":"%s"', ident(node_depth), json_key, func))
end

---A json handler for lua userdata
local function userdata_handler(json_key, u, node_depth, bake_Fn)
	bake_Fn = bake_Fn and bake_Fn or bake_json
	-- engine timestamp to RFC3339 +02:00 (because monolith is in ukraine).
	if u.timeToString then 
		local dt = utils_data.CTime_to_table(u)
		local rfc3339 = string.format('%04d-%02d-%02dT%02d:%02d:%02d.%03d+02:00', dt.Y, dt.M, dt.D, dt.h, dt.m, dt.s, dt.ms)
		return bake_Fn(string.format('%s"%s": "%s"', ident(node_depth), json_key, rfc3339))
	end
	-- Append new userdata convertions here
	return bake_Fn(string.format('%s"%s": "%s"', ident(node_depth), json_key, "unsupported userdata type"))
end

---register json_handlers after the compilier kowns about the handlers
json_handlers = {
	["boolean"] = boolean_handler,
	["function"] = function_handler,
	["nil"] = nil_handler,
	["number"] = number_handler,
	["string"] = string_handler,
	["table"] = table_handler,
	["userdata"] = userdata_handler,
}

--------------------------------------------------------------
-- Global functions
--------------------------------------------------------------

---to_json takes a Lua value and a desired key name and creates a valid json.
---@param value any any of boolean, number, string, table, userdata (CTime -> RFC3339+02:00) and nil 
---@param keyname string
---@return string
function to_json(value, keyname) 
	return type_dispatcher(keyname, value, 1)
end

---to_logfile takes a Lua value and a desired filename and writes the valid json representation to 
---./appdata/logs/filename.json. The filename is handled as the root-node json key.
---@param value any any of `boolean, number, string, table, userdata (CTime -> RFC3339+02:00) and nil`
---@param filename string
function to_logfile(value, filename)
	local appdatalog = getFS():update_path("$logs$","")
	local logfile = io.open(appdatalog .. "/" .. filename .. ".json","w")
	if logfile ~= nil then
		logfile:write(type_dispatcher(filename, value, 1))
		logfile:close()
	else 
		printdbg("~ utils_json | the file [%s.json] is unavailable", filename)
	end
end